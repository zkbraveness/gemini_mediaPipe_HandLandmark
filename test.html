<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI éš”ç©ºæ‰‹åŠ¿å†™å­—ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #1e1e1e; font-family: sans-serif; }
        
        /* è§†é¢‘å±‚ï¼šéšè—ï¼Œä½†éœ€è¦å­˜åœ¨ä»¥ä¾›å¤„ç† */
        #input_video { display: none; }
        
        /* ç”»å¸ƒå±‚ï¼šå…¨å±æ˜¾ç¤º */
        #output_canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤ºï¼Œç¬¦åˆç›´è§‰ */
        }

        /* UI é¢æ¿å±‚ï¼šä¸é•œåƒï¼Œå› ä¸ºæ–‡å­—éœ€è¦æ­£å‘æ˜¾ç¤º */
        #ui_layer {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 2;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€ï¼Œæˆ‘ä»¬ç”¨æ‰‹åŠ¿æ§åˆ¶ */
            display: none; /* é»˜è®¤éšè— */
        }

        .panel {
            position: absolute;
            bottom: 20px;  /* è·ç¦»åº•éƒ¨20px */
            right: 20px;   /* è·ç¦»å³ä¾§20px */
            transform: none; /* ç§»é™¤å±…ä¸­çš„å¹³ç§»å˜æ¢ */
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
            width: 400px;
        }

        .panel h2 { margin: 0 0 10px 0; text-align: center; color: #333; }
        
        .control-group { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        
        .btn {
            border: 2px solid #ccc;
            border-radius: 8px;
            padding: 10px 15px;
            background: #fff;
            font-weight: bold;
            transition: 0.3s;
        }
        
        .btn.active { border-color: #007bff; background: #e7f1ff; transform: scale(1.1); }
        
        .color-btn { width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ddd; }
        
        /* è™šæ‹Ÿå…‰æ ‡ */
        #cursor {
            position: absolute;
            width: 20px; height: 20px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: none;
            pointer-events: none;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="loading">æ­£åœ¨åŠ è½½æ¨¡å‹ï¼Œè¯·ç¨å€™...<br><small>è¯·ç¡®ä¿å…è®¸æ‘„åƒå¤´æƒé™</small></div>

    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>

    <div id="cursor"></div>

    <div id="ui_layer">
        <div class="panel" id="settings_panel">
            <h2>å·¥å…·ç®±</h2>
            
            <div class="control-group">
                <div class="btn active" id="tool_pen" data-type="tool" data-val="pen">ğŸ–Šï¸ ç¬”</div>
                <div class="btn" id="tool_eraser" data-type="tool" data-val="eraser">ğŸ§½ æ©¡çš®</div>
            </div>

            <div class="control-group">
                <div class="btn color-btn active" style="background: #ff0000;" data-type="color" data-val="#ff0000"></div>
                <div class="btn color-btn" style="background: #00ff00;" data-type="color" data-val="#00ff00"></div>
                <div class="btn color-btn" style="background: #0000ff;" data-type="color" data-val="#0000ff"></div>
                <div class="btn color-btn" style="background: #ffffff;" data-type="color" data-val="#ffffff"></div>
                <div class="btn color-btn" style="background: #ffff00;" data-type="color" data-val="#ffff00"></div>
            </div>

            <div class="control-group">
                <div class="btn" data-type="size" data-val="5">ç»†</div>
                <div class="btn active" data-type="size" data-val="10">ä¸­</div>
                <div class="btn" data-type="size" data-val="20">ç²—</div>
                <div class="btn" data-type="size" data-val="40">ç‰¹ç²—</div>
            </div>
            
            <p style="text-align:center; color:#666; font-size: 12px;">å¼ å¼€æ‰‹æŒé€€å‡º</p>
        </div>
    </div>

<script>
    // --- å˜é‡åˆå§‹åŒ– ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const uiLayer = document.getElementById('ui_layer');
    const cursor = document.getElementById('cursor');
    const panel = document.getElementById('settings_panel');
    const loadingDiv = document.getElementById('loading');

    // çŠ¶æ€ç®¡ç†
    let state = {
        isMenuOpen: false,
        tool: 'pen', // 'pen' or 'eraser'
        color: '#ff0000',
        lineWidth: 10,
        globalScale: 1.0,
        lastPinchDistance: null, // ç”¨äºç¼©æ”¾
        menuCooldown: 0 // é˜²æ­¢èœå•é¢‘ç¹å¼€å…³
    };

    // ç»˜ç”»æ•°æ®
    let paths = []; // å­˜å‚¨æ‰€æœ‰ç¬”ç”»: [{points: [{x, y}], color, width}]
    let currentPath = [];
    let particles = []; // é›ªèŠ±ç²’å­

    // è®¾ç½®ç”»å¸ƒå°ºå¯¸
    function resizeCanvas() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- MediaPipe è®¾ç½® ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });
    camera.start();

    // --- æ ¸å¿ƒé€»è¾‘å¾ªç¯ ---
    function onResults(results) {
        loadingDiv.style.display = 'none';
        
        // 1. æ¸…ç©ºå’Œç»˜åˆ¶æ‘„åƒå¤´èƒŒæ™¯ (é•œåƒå¤„ç†åœ¨CSSä¸­åšäº†ï¼Œè¿™é‡Œç»˜åˆ¶åŸå§‹å›¾åƒ)
        // æ³¨æ„ï¼šå› ä¸ºCSS flipäº†canvasï¼Œæ‰€ä»¥æˆ‘ä»¬ç”»å›¾æ—¶é€»è¾‘åæ ‡è¦æ˜¯æ­£å¸¸çš„
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // ç»˜åˆ¶æ‘„åƒå¤´ç”»é¢ï¼ˆå¯é€‰ï¼Œå¦‚æœæƒ³çœ‹å®æ™¯ï¼‰
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        // ç»˜åˆ¶å·²æœ‰çš„ç¬”ç”»
        drawPaths(canvasCtx);
        
        // ç»˜åˆ¶é›ªèŠ±
        updateAndDrawParticles(canvasCtx);

        // å¤„ç†æ‰‹åŠ¿
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handleGestures(results.multiHandLandmarks);
        } else {
            // æ²¡æœ‰æ‰‹çš„æ—¶å€™ï¼Œç»“æŸå½“å‰ç¬”ç”»
            if(currentPath.length > 0) {
                paths.push({
                    points: currentPath,
                    color: state.tool === 'eraser' ? 'global-eraser' : state.color, // æ ‡è®°æ©¡çš®æ“¦
                    width: state.lineWidth,
                    isEraser: state.tool === 'eraser'
                });
                currentPath = [];
            }
            state.lastPinchDistance = null;
        }
        
        canvasCtx.restore();
        
        // æ›´æ–°å†·å´æ—¶é—´
        if(state.menuCooldown > 0) state.menuCooldown--;
    }

    // --- æ‰‹åŠ¿å¤„ç†é€»è¾‘ ---
    function handleGestures(landmarksList) {
        const width = canvasElement.width;
        const height = canvasElement.height;

        // --- åœºæ™¯ 1: åŒæ‰‹æ“ä½œ (ç¼©æ”¾) ---
        if (landmarksList.length === 2) {
            // ä¸¤ä¸ªé£ŸæŒ‡æŒ‡å°– (Index Tip is index 8)
            const h1 = landmarksList[0][8];
            const h2 = landmarksList[1][8];
            
            // ç®€å•åˆ¤æ–­ï¼šå¦‚æœä¸¤åªæ‰‹éƒ½æ˜¯é£ŸæŒ‡ä¼¸å‡ºï¼ˆè¿™é‡Œç®€åŒ–ï¼Œåªæ£€æŸ¥æ˜¯å¦éƒ½æœ‰æ‰‹ï¼‰
            // è®¡ç®—ä¸¤ç‚¹è·ç¦»
            const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
            
            if (state.lastPinchDistance != null) {
                const delta = dist - state.lastPinchDistance;
                // è°ƒæ•´å…¨å±€ç¼©æ”¾
                state.globalScale += delta * 2; 
                state.globalScale = Math.max(0.1, Math.min(state.globalScale, 5.0));
            }
            state.lastPinchDistance = dist;
            
            // åŒæ‰‹æ—¶ä¸å†™å­—
            currentPath = [];
            return; 
        } else {
            state.lastPinchDistance = null;
        }

        // --- åœºæ™¯ 2: å•æ‰‹æ“ä½œ ---
        const lm = landmarksList[0]; // åªå–ç¬¬ä¸€åªæ‰‹

        // å…³é”®ç‚¹åæ ‡
        const indexTip = { x: lm[8].x * width, y: lm[8].y * height };
        const thumbTip = { x: lm[4].x * width, y: lm[4].y * height };
        const middleTip = { x: lm[12].x * width, y: lm[12].y * height };

        // 1. æ£€æµ‹æ‰‹æŒå¼ å¼€ (Open Palm) -> åˆ‡æ¢èœå•
        if (isPalmOpen(lm) && state.menuCooldown === 0) {
            toggleMenu();
            state.menuCooldown = 30; // å†·å´å¤§çº¦ 1 ç§’
            return;
        }

        // 2. å¦‚æœèœå•æ‰“å¼€ï¼Œå¤„ç† UI äº¤äº’
        if (state.isMenuOpen) {
            // åœ¨ UI æ¨¡å¼ä¸‹ï¼Œä¸å†™å­—ï¼Œæ˜¾ç¤ºå…‰æ ‡
            // æ³¨æ„ï¼šCanvasè¢«CSSç¿»è½¬äº†ï¼Œä½†DOMå…ƒç´ (UI)æ²¡æœ‰ç¿»è½¬ã€‚
            // è¿™é‡Œçš„ indexTip æ˜¯åŸºäº Canvas åæ ‡çš„ (0,0 åœ¨å·¦ä¸Šï¼Œä½†æ˜¾ç¤ºæ˜¯é•œåƒçš„)ã€‚
            // ä¸ºäº†è®©å…‰æ ‡è·Ÿæ‰‹å¯¹é½ï¼Œæˆ‘ä»¬éœ€è¦åè½¬ X åæ ‡æ¥åŒ¹é…éé•œåƒçš„ UI å±‚ DOM åæ ‡ã€‚
            const uiX = width - indexTip.x; 
            const uiY = indexTip.y;

            cursor.style.display = 'block';
            cursor.style.left = uiX + 'px';
            cursor.style.top = uiY + 'px';

            checkUICollision(uiX, uiY);
            return;
        } else {
            cursor.style.display = 'none';
        }

        // 3. æ£€æµ‹ "å‰ªåˆ€æ‰‹/èƒœåˆ©" (Peace) -> è§¦å‘é›ªèŠ±æ¶ˆæ•£
        if (isVictorySign(lm)) {
            triggerSnowEffect();
            return;
        }

        // 4. æ£€æµ‹ "æåˆ" (Pinch) -> å†™å­—
        const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
        if (pinchDist < 0.05) {
            // æ­£åœ¨å†™å­—
            // è®¡ç®—ä¸­ç‚¹ä½œä¸ºç¬”è§¦ä½ç½®
            const drawX = (indexTip.x + thumbTip.x) / 2;
            const drawY = (indexTip.y + thumbTip.y) / 2;
            
            // åº”ç”¨åå‘ç¼©æ”¾é€»è¾‘ï¼Œä½¿å¾—å­—æ˜¯è®°å½•åœ¨ç»å¯¹ç©ºé—´é‡Œçš„
            // ç®€å•èµ·è§ï¼Œæˆ‘ä»¬è®°å½•å½“å‰å±å¹•åæ ‡ï¼Œæ¸²æŸ“æ—¶åº”ç”¨ç¼©æ”¾ä¸­å¿ƒå˜åŒ–æ¯”è¾ƒå¤æ‚ã€‚
            // è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨ç®€åŒ–æ–¹æ¡ˆï¼šç›´æ¥è®°å½•åæ ‡ï¼Œç¼©æ”¾æ—¶æ”¹å˜ Canvas transformã€‚
            // ä¸ºäº†æ”¯æŒç¼©æ”¾åè¿˜èƒ½åœ¨æ­£ç¡®ä½ç½®ç»§ç»­å†™ï¼Œéœ€è¦å°†å½“å‰åæ ‡è½¬æ¢ä¸ºâ€œä¸–ç•Œåæ ‡â€ã€‚
            // ä½†ä¸ºä¿æŒä»£ç å•æ–‡ä»¶ç®€æ´ï¼Œæˆ‘ä»¬å®ç°ä¸€ä¸ª åŸºäºä¸­å¿ƒç‚¹çš„ç®€å•ç¼©æ”¾æ¸²æŸ“ã€‚
            // æ‰€ä»¥å­˜å‚¨æ—¶å­˜å‚¨ åŸå§‹åæ ‡ / globalScaleã€‚
            
            // ä¿®æ­£ï¼šæ›´ç®€å•çš„ç¼©æ”¾é€»è¾‘æ˜¯åªåœ¨æ¸²æŸ“æ—¶ scaleï¼Œå†™å­—æ—¶è®°å½•ç›¸å¯¹ä¸­å¿ƒçš„åç§»
            const centerX = width / 2;
            const centerY = height / 2;
            const worldX = (drawX - centerX) / state.globalScale + centerX;
            const worldY = (drawY - centerY) / state.globalScale + centerY;

            currentPath.push({ x: worldX, y: worldY });
        } else {
            // æŠ¬èµ·ç¬”
            if (currentPath.length > 0) {
                paths.push({
                    points: currentPath,
                    color: state.tool === 'eraser' ? '#000000' : state.color, // æ©¡çš®æ“¦é€»è¾‘ç¨åå¤„ç†
                    width: state.lineWidth,
                    isEraser: state.tool === 'eraser'
                });
                currentPath = [];
            }
        }
    }

    // --- è¾…åŠ©ç®—æ³• ---

    // åˆ¤æ–­æ‰‹æŒå¼ å¼€ (æ‰€æœ‰æ‰‹æŒ‡ä¼¸ç›´)
    function isPalmOpen(lm) {
        // ç®€å•åˆ¤æ–­ï¼šæŒ‡å°– y å°äº æŒ‡å…³èŠ‚ y (å‡è®¾æ‰‹å‘ä¸Š) æˆ–è€…æ ¹æ®è·ç¦»åˆ¤æ–­
        // è¿™é‡Œç”¨æ‰‹æŒ‡ä¼¸ç›´åˆ¤æ–­ï¼šæŒ‡å°–åˆ°æŒå¿ƒè·ç¦» > æŒ‡å…³èŠ‚åˆ°æŒå¿ƒè·ç¦»
        const wrist = lm[0];
        const tips = [8, 12, 16, 20];
        const pips = [6, 10, 14, 18];
        
        let openCount = 0;
        for (let i = 0; i < tips.length; i++) {
            if (dist(lm[tips[i]], wrist) > dist(lm[pips[i]], wrist)) {
                openCount++;
            }
        }
        // æ‹‡æŒ‡å•ç‹¬åˆ¤æ–­
        if (dist(lm[4], lm[17]) > dist(lm[3], lm[17])) openCount++;

        return openCount === 5;
    }

    // åˆ¤æ–­èƒœåˆ©æ‰‹åŠ¿ (é£ŸæŒ‡ä¸­æŒ‡ä¼¸ç›´ï¼Œæ— åæŒ‡å°æŒ‡å¼¯æ›²)
    function isVictorySign(lm) {
        const wrist = lm[0];
        const indexOpen = dist(lm[8], wrist) > dist(lm[6], wrist);
        const middleOpen = dist(lm[12], wrist) > dist(lm[10], wrist);
        const ringClosed = dist(lm[16], wrist) < dist(lm[14], wrist);
        const pinkyClosed = dist(lm[20], wrist) < dist(lm[18], wrist);

        return indexOpen && middleOpen && ringClosed && pinkyClosed;
    }

    function dist(p1, p2) {
        return Math.hypot(p1.x - p2.x, p1.y - p2.y);
    }

    // --- UI äº¤äº’ ---
    function toggleMenu() {
        state.isMenuOpen = !state.isMenuOpen;
        uiLayer.style.display = state.isMenuOpen ? 'block' : 'none';
    }

    function checkUICollision(x, y) {
        // è·å–æ‰€æœ‰æŒ‰é’®
        const buttons = document.querySelectorAll('.btn');
        let hit = false;

        buttons.forEach(btn => {
            const rect = btn.getBoundingClientRect();
            if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                hit = true;
                // é€‰ä¸­é€»è¾‘
                activateButton(btn);
            }
        });
    }

    function activateButton(btn) {
        const type = btn.getAttribute('data-type');
        const val = btn.getAttribute('data-val');

        // æ›´æ–° UI æ ·å¼
        const siblings = btn.parentElement.querySelectorAll('.btn');
        siblings.forEach(s => s.classList.remove('active'));
        btn.classList.add('active');

        // æ›´æ–°çŠ¶æ€
        if (type === 'tool') state.tool = val;
        if (type === 'color') state.color = val;
        if (type === 'size') state.lineWidth = parseInt(val);
    }

    // --- ç»˜å›¾ä¸ç‰¹æ•ˆ ---

    function drawPaths(ctx) {
        const centerX = canvasElement.width / 2;
        const centerY = canvasElement.height / 2;

        ctx.save();
        // åº”ç”¨ç¼©æ”¾ä¸­å¿ƒ
        ctx.translate(centerX, centerY);
        ctx.scale(state.globalScale, state.globalScale);
        ctx.translate(-centerX, -centerY);

        // ç»˜åˆ¶å†å²è·¯å¾„
        for (const pathObj of paths) {
            ctx.beginPath();
            ctx.lineWidth = pathObj.width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (pathObj.isEraser) {
                ctx.globalCompositeOperation = 'destination-out'; // æ©¡çš®æ“¦æ¨¡å¼
                ctx.strokeStyle = "rgba(0,0,0,1)";
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = pathObj.color;
            }

            if (pathObj.points.length > 0) {
                ctx.moveTo(pathObj.points[0].x, pathObj.points[0].y);
                for (let i = 1; i < pathObj.points.length; i++) {
                    ctx.lineTo(pathObj.points[i].x, pathObj.points[i].y);
                }
            }
            ctx.stroke();
        }

        // ç»˜åˆ¶å½“å‰æ­£åœ¨å†™çš„è·¯å¾„
        if (currentPath.length > 0) {
            ctx.beginPath();
            ctx.lineWidth = state.lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            if (state.tool === 'eraser') {
                 ctx.globalCompositeOperation = 'destination-out';
                 ctx.strokeStyle = "rgba(0,0,0,1)";
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = state.color;
            }
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) {
                ctx.lineTo(currentPath[i].x, currentPath[i].y);
            }
            ctx.stroke();
        }

        ctx.restore();
        // é‡ç½®æ··åˆæ¨¡å¼ä»¥å…å½±å“åç»­ç»˜åˆ¶
        ctx.globalCompositeOperation = 'source-over';
    }

    // --- é›ªèŠ±ç‰¹æ•ˆé€»è¾‘ ---
    
    function triggerSnowEffect() {
        if (paths.length === 0 && currentPath.length === 0) return;

        // å°†æ‰€æœ‰è·¯å¾„ç‚¹è½¬æ¢ä¸ºç²’å­
        const centerX = canvasElement.width / 2;
        const centerY = canvasElement.height / 2;

        // æ”¶é›†æ‰€æœ‰ç‚¹
        let allPoints = [];
        
        // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨å½“å‰çš„ç¼©æ”¾è·å–å®é™…å±å¹•ä½ç½®
        const getScreenPos = (pt) => {
            return {
                x: (pt.x - centerX) * state.globalScale + centerX,
                y: (pt.y - centerY) * state.globalScale + centerY
            };
        };

        paths.forEach(p => {
            if(!p.isEraser) { // æ©¡çš®æ“¦è½¨è¿¹ä¸å˜æˆé›ªèŠ±
                p.points.forEach(pt => {
                    // åªæœ‰ä¸€å®šæ¦‚ç‡ç”Ÿæˆç²’å­ï¼Œé˜²æ­¢è¿‡å¡
                    if(Math.random() > 0.5) { 
                        const screenPt = getScreenPos(pt);
                        allPoints.push({
                            x: screenPt.x,
                            y: screenPt.y,
                            color: p.color,
                            size: Math.random() * 3 + 1
                        });
                    }
                });
            }
        });

        // æ­£åœ¨å†™çš„ä¹Ÿç®—
        currentPath.forEach(pt => {
             const screenPt = getScreenPos(pt);
             allPoints.push({x: screenPt.x, y: screenPt.y, color: state.color, size: 2});
        });

        // ç”Ÿæˆç²’å­å¯¹è±¡
        allPoints.forEach(pt => {
            particles.push({
                x: pt.x,
                y: pt.y,
                vx: (Math.random() - 0.5) * 2,
                vy: Math.random() * 2 + 1, // å‘ä¸‹é£˜
                life: 1.0,
                color: pt.color,
                size: pt.size
            });
        });

        // æ¸…ç©ºè·¯å¾„
        paths = [];
        currentPath = [];
        // é‡ç½®ç¼©æ”¾ï¼Œå¦åˆ™æ–°å­—ä¼šä¹±
        state.globalScale = 1.0; 
    }

    function updateAndDrawParticles(ctx) {
        if (particles.length === 0) return;

        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            
            // æ›´æ–°ç‰©ç†
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.01; // é€æ¸æ¶ˆå¤±
            
            // æ‘†åŠ¨æ•ˆæœ
            p.x += Math.sin(p.y * 0.05) * 0.5;

            // ç»˜åˆ¶
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();

            // ç§»é™¤æ­»æ‰çš„ç²’å­
            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }
        ctx.globalAlpha = 1.0;
    }

</script>
</body>
</html>
